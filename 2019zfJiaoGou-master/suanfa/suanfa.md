## 算法的衡量

- 前言：前端提高算法性能的意义
  - 我们常常听说，前端只要实现功能就可以，不用在意程序的执行时间，真的是这样吗？其实不然，相比服务端，前端在很大程度上对性能有更高的要求，主要是基于以下俩点考虑：
     - 流畅问题  --- 为了保证动画的流畅进行，每一帧动画我们只有（1000/60）ms = 16ms时间来执行其他计算过程。播放动画的同时我们可能还在请求数据，改变DOM结构、响应事件。（从某种意义上说服务端轻松得多，因为他们的接口程序通常只需要在100ms内完成执行）
     - 老旧机型 --- 前端还有大量机型需要适配，这些机型可能性能没有那么好（比如华为荣耀4a，Android 5.1）,在这台机器上亲测一个未经优化设计50多张页面的路由算法执行时间为500ms。如果算法设计失误，在一台机器上执行的算法可能会在另一台机器上产生雪崩效果



- 预习：算法依赖的模型
```
 我们假设cpu会顺序的执行所有的指令，而内存随机访问的代价是相同的，例如：
 而与内存最相近的数据结构就是数组，那么我们认为，对于任何一个我们定义的数组“
 const a=[1,2,3,4,5]
 
 它的索引操作，占用1单位时间（也就是消耗1的cpu指令）
 
 a[2]
```
- 课前思考题目 ：100w整数数据的排序
  - 先生成1-100w的整数
  - 写一个算法将他们随机打乱
  - 在写一个算法对他们进行排序
  - 最后输出一下自己程序的总执行时间
  - 1.课前思考题目.js

- 前置知识：大数定理
  - 在随机事件的大量重复出现中，往往呈现几乎必然的规律，这个规律就是大数定律
  - 比如抛硬币，次数多了之后（比如1万次），正面朝上和反面朝上的数量会趋同
  
- 前置知识：需要用到的俩个希腊字母
  - 算法复杂度的衡量用到3个字母，分别是O，θ，Ω是俩个希腊字母

- 前置知识：对数函数
  ```
  在衡量算法复杂度的过程当中常常用到的对数函数，对数是指数的逆运算：* 2的10次方=1024  <=> log底数为2的1024 =10
  
  比如需要从100万数据中查找结果，算法可以在log底数为10的N 的时间内完成，那么100w数据查找结果，需要处理log底数为10的100,0000 =6 次计算。那么这样的查找操作，速度是相对比较快的
  

  ```      
- 复杂度的表示

```
算法通常执行时间是一个区域，算法的执行时间，空间消耗，会随着输入规模的变化而变化，我们用下面的术语来描述这种变化的关系
O： 渐进上界
θ： 渐进下界
Ω： 渐进紧密界
```

- Divide& Conquer(分治)
  - 分：将问题分解成子问题，子问题规模变小但问题不变
  - 治：递归解决子问题，子问题的子问题，当子问题足够小，就直接解决
  - 合：合并子问题的解
  
  - 代表：归并排序，快速排序